diff --git a/cordovaqt.pro b/cordovaqt.pro
index 61d823b..1ddbb27 100644
--- a/cordovaqt.pro
+++ b/cordovaqt.pro
@@ -21,7 +21,8 @@ SOURCES += main.cpp \
     src/plugins/accelerometer.cpp \
     src/plugins/events.cpp \
     src/cordova.cpp \
-    src/cplugin.cpp
+    src/cplugin.cpp \
+    src/plugins/camera.cpp
 HEADERS += \
     src/plugins/notification.h \
     src/plugins/geolocation.h \
@@ -34,7 +35,9 @@ HEADERS += \
     src/plugins/accelerometer.h \
     src/plugins/events.h \
     src/cordova.h \
-    src/cplugin.h
+    src/cplugin.h \
+    src/plugins/camera.h \
+    src/plugins/cameraresolution.h
 
 greaterThan(QT_MAJOR_VERSION, 4) {
     message("Qt5 build")
diff --git a/src/plugins/camera.cpp b/src/plugins/camera.cpp
new file mode 100644
index 0000000..955d6f3
--- /dev/null
+++ b/src/plugins/camera.cpp
@@ -0,0 +1,137 @@
+#include "cameraresolution.h"
+#include "camera.h"
+
+#ifdef Q_OS_SYMBIAN
+#include <ecam.h>
+#include <NewFileServiceClient.h>
+#include <AiwServiceHandler.h>
+#include <AiwCommon.hrh>
+#include <AiwGenericParam.hrh>
+#endif
+
+#include <QDebug>
+
+Camera::Camera() : CPlugin(){
+    PluginRegistry::getRegistry()->registerPlugin( "com.cordova.Camera", this );
+}
+
+Camera::~Camera()
+{
+    qDeleteAll(m_supportedResolutionObjects);
+}
+
+void Camera::init(){
+    getSupportedResolutions();
+}
+
+void Camera::getPicture( int scId, int ecId, QVariantMap p_options){
+    Q_UNUSED(ecId);
+    Q_UNUSED(p_options);
+
+    // Should we select the best resolution here?
+    QString callbackArguments = newImageFile(m_supportedResolutions.at(0).width(),m_supportedResolutions.at(0).height());
+
+    this->callback( scId, callbackArguments );
+}
+
+QString Camera::newImageFile(int width, int height)
+{
+#ifdef Q_OS_SYMBIAN
+    QString filename;
+    TRAPD(err, filename = symbianCapture(width, height));
+    if (err != KErrNone)
+        emit error(err);
+    return filename;
+#else
+    return DUMMY_IMAGE;
+#endif
+}
+
+QUrl Camera::newImageUrl(int width, int height)
+{
+    QString filename = newImageFile(width, height);
+    if (filename.isEmpty())
+        return QUrl();
+    else
+        return QUrl::fromLocalFile(filename);
+}
+
+
+QList<QSize> Camera::supportedResolutions()
+{
+    if (m_supportedResolutions.isEmpty())
+        getSupportedResolutions();
+    return m_supportedResolutions;
+}
+
+void Camera::getSupportedResolutions()
+{
+#ifdef Q_OS_SYMBIAN
+    TRAPD(err, symbianEnumerateResolutions());
+#else
+    m_supportedResolutions.append(QSize(DUMMY_WIDTH, DUMMY_HEIGHT));
+    m_supportedResolutionObjects.append(new CameraResolution(DUMMY_WIDTH, DUMMY_HEIGHT));
+#endif
+}
+
+QList<QObject*> Camera::supportedResolutionObjects()
+{
+    if (m_supportedResolutionObjects.isEmpty())
+        getSupportedResolutions();
+    return m_supportedResolutionObjects;
+}
+
+#ifdef Q_OS_SYMBIAN
+QString Camera::symbianCapture(int width, int height)
+{
+    CNewFileServiceClient* fileClient = NewFileServiceFactory::NewClientL();
+    CleanupStack::PushL(fileClient);
+
+    CDesCArray* fileNames = new (ELeave) CDesCArrayFlat(1);
+    CleanupStack::PushL(fileNames);
+
+    CAiwGenericParamList* paramList = CAiwGenericParamList::NewLC();
+
+    TSize resolution = TSize(width, height);
+    TPckgBuf<TSize> buffer( resolution );
+    TAiwVariant resolutionVariant( buffer );
+    TAiwGenericParam param( EGenericParamResolution, resolutionVariant );
+    paramList->AppendL( param );
+
+    const TUid KUidCamera = { 0x101F857A }; // Camera UID for S60 5th edition
+
+    TBool result = fileClient->NewFileL( KUidCamera, *fileNames, paramList,
+                               ENewFileServiceImage, EFalse );
+
+    QString ret;
+
+    if (result) {
+        TPtrC fileName=fileNames->MdcaPoint(0);
+        ret = QString((QChar*) fileName.Ptr(), fileName.Length());
+    }
+     qDebug() << ret;
+    CleanupStack::PopAndDestroy(3);
+
+    return ret;
+}
+
+void Camera::symbianEnumerateResolutions()
+{
+    CCamera* camera = CCamera::NewL(*this, 0);
+    TCameraInfo info;
+    camera->CameraInfo(info);
+    int resolutionCount = info.iNumImageSizesSupported;
+    qDebug() << resolutionCount;
+    for (int i=0; i < resolutionCount; i++) {
+        TSize size;
+        camera->EnumerateCaptureSizes(size, i, CCamera::EFormatExif);
+        qDebug() << size.iWidth << size.iHeight;
+        m_supportedResolutions.append(QSize(size.iWidth, size.iHeight));
+        m_supportedResolutionObjects.append(new CameraResolution(size.iWidth, size.iHeight));
+    }
+    qDebug() << m_supportedResolutionObjects.length();
+    delete camera;
+
+}
+#endif
+
diff --git a/src/plugins/camera.h b/src/plugins/camera.h
new file mode 100644
index 0000000..1e9ee57
--- /dev/null
+++ b/src/plugins/camera.h
@@ -0,0 +1,70 @@
+#ifndef CAMERA_H
+#define CAMERA_H
+
+#include "../cplugin.h"
+#include "../pluginregistry.h"
+
+#include <QObject>
+#include <QUrl>
+#include <QList>
+#include <QSize>
+#include <QVariantMap>
+
+
+// This is returned as the path to the captured image on platforms other than Symbian
+#define DUMMY_IMAGE "dummy.jpg"
+
+// These define the (only) supported resolution on platforms other than Symbian
+#define DUMMY_WIDTH 1024
+#define DUMMY_HEIGHT 768
+
+#ifdef Q_OS_SYMBIAN
+#include <ecam.h>
+#endif
+
+#ifdef QTM_NAMESPACE
+QTM_USE_NAMESPACE
+#endif
+
+class Camera : public CPlugin
+{
+#ifdef Q_OS_SYMBIAN
+    , public MCameraObserver
+#endif
+
+    Q_OBJECT
+public:
+    explicit Camera();
+    void init();
+    ~Camera();
+
+    QString newImageFile(int width, int height);
+    QUrl newImageUrl(int width, int height);
+    QList<QSize> supportedResolutions();
+
+
+signals:
+
+public slots:
+    void getPicture( int scId, int ecId, QVariantMap p_options);
+
+
+private:
+#ifdef Q_OS_SYMBIAN
+    QString symbianCapture(int width, int height);
+    void symbianEnumerateResolutions();
+    void FrameBufferReady(MFrameBuffer* aFrameBuffer,TInt aError) {}
+    void ImageReady(CFbsBitmap* aBitmap,HBufC8* aData,TInt aError) {}
+    void ViewFinderFrameReady(CFbsBitmap& aFrame) {}
+    void PowerOnComplete(TInt aError) {};
+    void ReserveComplete(TInt aError) {};
+#endif
+    void getSupportedResolutions();
+    QList<QObject*> supportedResolutionObjects();
+
+private:
+    QList<QSize> m_supportedResolutions;
+    QList<QObject*> m_supportedResolutionObjects;
+};
+
+#endif // CAMERA_H
diff --git a/src/plugins/cameraresolution.h b/src/plugins/cameraresolution.h
new file mode 100644
index 0000000..ca70b29
--- /dev/null
+++ b/src/plugins/cameraresolution.h
@@ -0,0 +1,22 @@
+#ifndef CAMERARESOLUTION_H
+#define CAMERARESOLUTION_H
+
+#include <QObject>
+
+class CameraResolution : public QObject
+{
+    Q_OBJECT
+
+    Q_PROPERTY(int width READ width CONSTANT)
+    Q_PROPERTY(int height READ height CONSTANT)
+
+public:
+    CameraResolution(int width, int height) : m_width(width), m_height(height) {}
+    int width() { return m_width; }
+    int height() { return m_height; }
+
+    int m_width;
+    int m_height;
+};
+
+#endif // CAMERARESOLUTION_H
diff --git a/www/basic.js b/www/basic.js
index 3ce3f66..6d929f6 100644
--- a/www/basic.js
+++ b/www/basic.js
@@ -83,6 +83,20 @@ function getCurrentAcceleration() {
 
 }
 
+function getPicture(){
+    navigator.camera.getPicture(function(picture_file){
+                                    get("picture_val").innerHTML = '<img src="' + picture_file +'" />';
+                                },
+                                function(){
+                                },
+                                { quality : 75,
+                                  destinationType : Camera.DestinationType.DATA_URL,
+                                  sourceType : Camera.PictureSourceType.CAMERA,
+                                  allowEdit : true,
+                                  encodingType: Camera.EncodingType.JPEG,
+                                  targetWidth: 100,
+                                  targetHeight: 100});
+}
 
 
 function test_requestFileSystem() {
diff --git a/www/index.html b/www/index.html
index 902b9de..b0a1e14 100644
--- a/www/index.html
+++ b/www/index.html
@@ -14,6 +14,7 @@
         <script language="javascript" type="text/javascript" src="js/notification.js"></script>
         <script language="javascript" type="text/javascript" src="js/compass.js"></script>
         <script language="javascript" type="text/javascript" src="js/accelerometer.js"></script>
+        <script language="javascript" type="text/javascript" src="js/camera.js"></script>
 
         <script language="javascript" type="text/javascript" src="basic.js"></script>
 
@@ -45,5 +46,9 @@
         <input type="button" value="Get Current Heading" onclick="getCurrentHeading();">
         <br />
         <div id="heading_val"> Heading </div>
+
+        <input type="button" value="Get Picture" onclick="getPicture();">
+        <br />
+        <div id="picture_val"> Picture</div>
     </body>
 </html>
diff --git a/www/js/camera.js b/www/js/camera.js
new file mode 100644
index 0000000..336e71c
--- /dev/null
+++ b/www/js/camera.js
@@ -0,0 +1,49 @@
+function Camera(){
+}
+
+Camera.prototype.DestinationType = {
+        DATA_URL : 0,                // Return image as base64 encoded string
+        FILE_URI : 1                 // Return image file URI
+};
+
+Camera.prototype.PictureSourceType = {
+    PHOTOLIBRARY : 0,
+    CAMERA : 1,
+    SAVEDPHOTOALBUM : 2
+};
+
+
+Camera.prototype.EncodingType = {
+     JPEG : 0,               // Return JPEG encoded image
+     PNG : 1                 // Return PNG encoded image
+};
+
+
+
+function CameraOptions() {
+};
+
+/*
+CameraOptions.prototype.magneticHeading = 0;
+
+quality : 75,
+                                  destinationType : Camera.DestinationType.DATA_URL,
+                                  sourceType : Camera.PictureSourceType.CAMERA,
+                                  allowEdit : true,
+                                  encodingType: Camera.EncodingType.JPEG,
+                                  targetWidth: 100,
+                                  targetHeight: 100
+*/
+
+Camera.prototype.getPicture = function( successCallback, errorCallback, options ) {
+    // Check the callbacks
+    if( typeof successCallback !== "function" ) return;
+    if( typeof errorCallback !== "function" ) errorCallback = function() {};
+    var cameraOptions = new CameraOptions();
+
+    // Call the native function
+    var me = this;
+    Cordova.exec( function( p_camera ) {
+                      successCallback( p_camera );
+                  }, errorCallback, "com.cordova.Camera", "getPicture", [ cameraOptions ] );
+};
